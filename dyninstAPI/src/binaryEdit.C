/*
 * Copyright (c) 1996-2009 Barton P. Miller
 * 
 * We provide the Paradyn Parallel Performance Tools (below
 * described as "Paradyn") on an AS IS basis, and do not warrant its
 * validity or performance.  We reserve the right to update, modify,
 * or discontinue this software at any time.  We shall have no
 * obligation to supply such updates or modifications or any other
 * form of support to you.
 * 
 * By your use of Paradyn, you understand and agree that we (or any
 * other person or entity with proprietary rights in Paradyn) are
 * under no obligation to provide either maintenance services,
 * update services, notices of latent defects, or correction of
 * defects for Paradyn.
 * 
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 */

// $Id: binaryEdit.C,v 1.26 2008/10/28 18:42:44 bernat Exp $

#include "binaryEdit.h"
#include "common/h/headers.h"
#include "mapped_object.h"
#include "mapped_module.h"
#include "multiTramp.h"
#include "debug.h"
#include "os.h"
#include "instPoint.h"
#include "function.h"

using namespace Dyninst::SymtabAPI;

// #define USE_ADDRESS_MAPS

// Reading and writing get somewhat interesting. We are building
// a false address space - that of the "inferior" binary we're editing. 
// However, that address space doesn't exist - and so we must overlay
// it on ours. In the dynamic case this is easy, of course. So what
// we have is a mapping. An "Address" that we get (inOther), can
// map to one of the following:
//  1) An area created with inferiorMalloc
//  2) A section of the binary that is original
//  3) A section of the binary that was modified

bool BinaryEdit::readTextSpace(const void *inOther,
                               u_int size,
                               void *inSelf) {
    Address addr = (Address) inOther;
    
    // Look up this address in the code range tree of memory
    codeRange *range = NULL;
    if (!memoryTracker_->find(addr, range))
        return false;
    assert(addr >= range->get_address());

    Address offset = addr - range->get_address();
    assert(offset < range->get_size());

    void *local_ptr = ((void *) (offset + (Address)range->get_local_ptr()));
    memcpy(inSelf, local_ptr, size);

    return true;
}

bool BinaryEdit::writeTextSpace(void *inOther,
                            u_int size,
                            const void *inSelf) {
    // This assumes we already have a memory tracker; inefficient, but
    // it works. 
    Address addr = (Address) inOther;
    unsigned int to_do = size;
    Address local = (Address) inSelf;
    markDirty();

    while (to_do) {
       // Look up this address in the code range tree of memory
       codeRange *range = NULL;
       if (!memoryTracker_->find(addr, range)) {
          return false;
       }
       
       // We might (due to fragmentation) be overlapping multiple backing
       // store "chunks", so this has to be iterative rather than a one-shot.
       
       Address chunk_start = range->get_address();
       Address chunk_end = range->get_address() + range->get_size();
       
       assert (addr >= chunk_start);
       
       unsigned chunk_size = 0;
       if ((addr + to_do) <= chunk_end) {
          chunk_size = to_do;
       }
       else {
          chunk_size = chunk_end - addr;
       }
       
       Address offset = addr - range->get_address();
       assert(offset < range->get_size());
       
       void *local_ptr = ((void *) (offset + (Address)range->get_local_ptr()));
       inst_printf("Copying to 0x%lx [base=0x%lx] from 0x%lx (%d bytes)  target=0x%lx  offset=0x%lx\n", 
              local_ptr, range->get_local_ptr(), local, chunk_size, addr, offset);
       //range->print_range();
       memcpy(local_ptr, (void *)local, chunk_size);
       memoryTracker* mt = dynamic_cast<memoryTracker*>(range);
       assert(mt);
       mt->dirty = true;
       
       to_do -= chunk_size;
       addr += chunk_size;
       local += chunk_size;
    }

    return true;
}    

bool BinaryEdit::readDataSpace(const void *inOther,
                           u_int amount,
                           void *inSelf,
                           bool) {
    return readTextSpace(inOther, amount, inSelf);
}

bool BinaryEdit::writeDataSpace(void *inOther,
                            u_int amount,
                            const void *inSelf) {
    return writeTextSpace(inOther, amount, inSelf);
}

bool BinaryEdit::readTextWord(const void *inOther,
                              u_int size,
                              void *inSelf)
{ return readTextSpace(inOther, size, inSelf); }

bool BinaryEdit::writeTextWord(void *inOther,
                               u_int size,
                               const void *inSelf)
{ return writeTextSpace(inOther, size, inSelf); }

bool BinaryEdit::readDataWord(const void *inOther,
                              u_int amount,
                              void *inSelf,
                              bool)
{ return readTextSpace(inOther, amount, inSelf); }

bool BinaryEdit::writeDataWord(void *inOther,
                               u_int amount,
                               const void *inSelf)
{ return writeTextSpace(inOther, amount, inSelf); }

const Address ADDRESS_LO = (Address)0;
const Address ADDRESS_HI = (Address)(~(Address)0);
const unsigned HEAP_STAT_BUF_SIZE = (0x100000);

Address BinaryEdit::inferiorMalloc(unsigned size,
                               inferiorHeapType /*ignored*/,
                               Address /*near*/,
                               bool *err) {
    // It looks like we're ignoring near...
    Address ret = 0;

    Address lo = ADDRESS_LO;
    Address hi = ADDRESS_HI;

    if (err) *err = false;
   
    inferiorMallocAlign(size); // align size

    int freeIndex = -1;
    int ntry = 0;
    for (ntry = 0; freeIndex == -1; ntry++) {
        switch(ntry) {
        case 0: 
            // See if we have available memory
            break;
        case 1:
            inferiorFreeCompact();
            break;
        case 2:
            inferiorMallocStatic(size);
            break;
        default:
            return 0;
        }
        ret = inferiorMallocInternal(size, lo, hi, anyHeap);
        if (ret) {
	  memoryTracker *newTracker = new memoryTracker(ret, size);
	  newTracker->alloced = true;
	  if (!memoryTracker_)
	    memoryTracker_ = new codeRangeTree();
	  memoryTracker_->insert(newTracker);

	  break;
	}
    }

    return ret;
}

void BinaryEdit::inferiorFree(Address item)
{
  inferiorFreeInternal(item);

  codeRange *obj;
  memoryTracker_->find(item, obj);
  
  delete obj;

  memoryTracker_->remove(item);
}

bool BinaryEdit::inferiorRealloc(Address item, unsigned newsize)
{
  bool result = inferiorReallocInternal(item, newsize);
  if (!result)
    return false;

  codeRange *obj;
  result = memoryTracker_->find(item, obj);
  assert(result);

  memoryTracker_->remove(item);

  memoryTracker *mem_track = dynamic_cast<memoryTracker *>(obj);
  assert(mem_track);
  mem_track->realloc(newsize);

  memoryTracker_->insert(obj);
  return true;
}

Architecture BinaryEdit::getArch() const {
    assert(mapped_objects.size());
   
    // XXX presumably all of the objects in the BinaryEdit collection
    //     must be the same architecture.
    return mapped_objects[0]->parse_img()->codeObject()->cs()->getArch();
}

unsigned BinaryEdit::getAddressWidth() const {
    assert(mapped_objects.size());
    
    return mapped_objects[0]->parse_img()->codeObject()->cs()->getAddressWidth();
}
Address BinaryEdit::offset() const {
    fprintf(stderr,"error BinaryEdit::offset() unimpl\n");
    return 0;
}
Address BinaryEdit::length() const {
    fprintf(stderr,"error BinaryEdit::length() unimpl\n");
    return 0;
}

bool BinaryEdit::multithread_capable(bool) {
   return multithread_capable_;
}

bool BinaryEdit::multithread_ready(bool) {
    return multithread_capable();
}

void BinaryEdit::deleteGeneratedCode(generatedCodeObject *del) {
  // This can happen - say that someone writes a file (which generates), 
  // then goes around uninstrumenting... yeah, it can happen.

  // Or a failed atomic insert.

    // No reason to delay deletion.
    delete del;
}

BinaryEdit::BinaryEdit() : 
   highWaterMark_(0),
   lowWaterMark_(0),
   isDirty_(false),
   memoryTracker_(NULL),
   multithread_capable_(false)
{
   trapMapping.shouldBlockFlushes(true);
}

BinaryEdit::~BinaryEdit() 
{
}

void BinaryEdit::deleteBinaryEdit() {
    deleteAddressSpace();
    highWaterMark_ = 0;
    lowWaterMark_ = 0;

    // TODO: is this cleanup necessary?
    depRelocation *rel;
    while (dependentRelocations.size() > 0) {
        rel = dependentRelocations[0];
        dependentRelocations.erase(dependentRelocations.begin());
        delete rel;
    }
}

BinaryEdit *BinaryEdit::openFile(const std::string &file, const std::string &member) {
    if (!OS::executableExists(file)) {
        startup_printf("%s[%d]:  failed to read file %s\n", FILE__, __LINE__, file.c_str());
        std::string msg = std::string("Can't read executable file ") + file + (": ") + strerror(errno);
        showErrorCallback(68, msg.c_str());
        return NULL;
    }
    
    fileDescriptor desc;
    if (!getStatFileDescriptor(file, desc)) {
        startup_printf("%s[%d]: failed to create file descriptor for %s!\n",
                       FILE__, __LINE__, file.c_str());
        return NULL;
    }

    // Open the mapped object as an archive member
    if( !member.empty() ) {
        desc.setMember(member);
    }

    BinaryEdit *newBinaryEdit = new BinaryEdit();
    if (!newBinaryEdit) {
        startup_printf("%s[%d]: failed to create binary representation for %s!\n",
                       FILE__, __LINE__, file.c_str());
    }

    newBinaryEdit->mobj = mapped_object::createMappedObject(desc, newBinaryEdit);
    if (!newBinaryEdit->mobj) {
        startup_printf("%s[%d]: failed to create mapped object for %s\n",
                       FILE__, __LINE__, file.c_str());
        return NULL;
    }

    newBinaryEdit->mapped_objects.push_back(newBinaryEdit->mobj);
    newBinaryEdit->addOrigRange(newBinaryEdit->mobj);

    // We now need to access the start of the new section we're creating.

    // I'm going through the mapped_object interface for now - 
    // I assume we'll pass it to DynSymtab, then add our base
    // address to it at the mapped_ level. 
    Symtab* linkedFile = newBinaryEdit->getAOut()->parse_img()->getObject();
    newBinaryEdit->highWaterMark_ = linkedFile->getFreeOffset(50*1024*1024);
    newBinaryEdit->lowWaterMark_ = newBinaryEdit->highWaterMark_;

    newBinaryEdit->makeInitAndFiniIfNeeded();

    newBinaryEdit->createMemoryBackingStore(newBinaryEdit->getAOut());
    newBinaryEdit->initialize();

    //Don't count initialization in determining dirty
    newBinaryEdit->isDirty_ = false; //!(foundInit && foundFini);
    return newBinaryEdit;
}

#if !defined(os_linux) && !defined(os_freebsd)
void BinaryEdit::makeInitAndFiniIfNeeded()
{
}

bool BinaryEdit::archSpecificMultithreadCapable() {
    return false;
}
#endif

bool BinaryEdit::getStatFileDescriptor(const std::string &name, fileDescriptor &desc) {
   desc = fileDescriptor(name.c_str(),
                         0, // code base address
                         0); // data base address
   return true;
}

#if !defined(os_linux) && !defined(os_solaris) && !defined(os_freebsd)
std::map<std::string, BinaryEdit*> BinaryEdit::openResolvedLibraryName(std::string filename) {
    /*
     * Note: this does not actually do any library name resolution, as that is OS-dependent
     * If resolution is required, it should be implemented in an OS-dependent file
     * (see linux.C for an example)
     *
     * However, this version allows the RT library to be opened with this function regardless
     * if library name resolution has been implemented on a platform.
     */
    std::map<std::string, BinaryEdit *> retMap;

    BinaryEdit *temp = BinaryEdit::openFile(filename);
    if( temp && temp->getAddressWidth() == getAddressWidth() ) {
        retMap.insert(std::make_pair(filename, temp));
        return retMap;
    }

    retMap.insert(std::make_pair("", static_cast < BinaryEdit * >(NULL)));
    return retMap;
}

bool BinaryEdit::getResolvedLibraryPath(const std::string &, std::vector<std::string> &) {
    assert(!"Not implemented");
    return false;
}
#endif

#if !(defined(cap_binary_rewriter) && (defined(arch_x86) || defined(arch_x86_64))) 
bool BinaryEdit::doStaticBinarySpecialCases() {
    return true;
}
#endif

bool BinaryEdit::isMultiThreadCapable()
{
   Symtab *symtab = mobj->parse_img()->getObject();
   std::vector<std::string> depends = symtab->getDependencies();
   for (std::vector<std::string>::iterator curDep = depends.begin();
        curDep != depends.end(); curDep++) {
     if(    (curDep->find("libpthread") != std::string::npos) 
         || (curDep->find("libthread") != std::string::npos)
         || (curDep->find("libthr") != std::string::npos) )
     {
        return true;
     }
   }

   return archSpecificMultithreadCapable();
}

bool BinaryEdit::getAllDependencies(std::map<std::string, BinaryEdit*>& deps)
{
   Symtab *symtab = mobj->parse_img()->getObject();
   std::deque<std::string> depends;
   std::copy(symtab->getDependencies().begin(), symtab->getDependencies().end(), std::back_inserter(depends));
   while(!depends.empty())
   {
     std::string lib = depends.front();
     if(deps.find(lib) == deps.end()) {
         std::map<std::string, BinaryEdit*> res = openResolvedLibraryName(lib);
         std::map<std::string, BinaryEdit*>::iterator bedit_it;
         for(bedit_it = res.begin(); bedit_it != res.end(); ++bedit_it) {
           if (bedit_it->second) {
             deps.insert(*bedit_it);
             if(!bedit_it->second->getAllDependencies(deps))
             {
               return false;
             }
           } else {
             return false;
           }
         }
     }
     depends.pop_front();
   }
   return true;
}

bool BinaryEdit::writeFile(const std::string &newFileName) 
{
   // We've made a bunch of changes and additions to the
   // mapped object.
   //   Changes: modifiedRanges_
   //   Additions: textRanges_, excepting the file itself. 
   // 
   // Although, since we're creating a new file name we want
   // textRanges. Basically, we want to serialize the contents
   // of textRanges_, dataRanges_, and modifiedRanges_.

   // A _lot_ of this method will depend on how the new file
   // generation ends up working. Do we provide buffers? I'm guessing
   // so.

   // Step 1: changes. 

      inst_printf(" writing %s ... \n", newFileName.c_str());

      Symtab *symObj = mobj->parse_img()->getObject();

      if( symObj->isStaticBinary() ) {
          if( !doStaticBinarySpecialCases() ) {
              return false;
          }
      }

      vector<Region*> oldSegs;
      symObj->getAllRegions(oldSegs);

      //vector<Region*> newSegs = oldSegs;

      //Write any traps to the mutatee
      trapMapping.shouldBlockFlushes(false);
      trapMapping.flush();

      // Now, we need to copy in the memory of the new segments
      for (unsigned i = 0; i < oldSegs.size(); i++) {
         codeRange *segRange = NULL;
         if (!memoryTracker_->find(oldSegs[i]->getRegionAddr(), segRange)) {
#if 0
            // Looks like BSS
            if (newSegs[i].name == ".bss")
#endif
               continue;
            //inst_printf (" segment name: %s\n", newSegs[i].name.c_str());
            //assert(0);
         }
         //inst_printf(" ==> memtracker: Copying to 0x%lx from 0x%lx\n", 
         //newSegs[i].loadaddr, segRange->get_local_ptr());
	 memoryTracker* mt = dynamic_cast<memoryTracker*>(segRange);
	 assert(mt);
	 if(mt->dirty) {
	   oldSegs[i]->setPtrToRawData(segRange->get_local_ptr(), oldSegs[i]->getRegionSize());
	 }
	 
         //newSegs[i].data = segRange->get_local_ptr();
      }

      // Okay, that does it for the old stuff.

      // Now we need to get the new stuff. That's all the allocated memory. First, big
      // buffer to hold it.

      void *newSectionPtr = malloc(highWaterMark_ - lowWaterMark_);

      pdvector<codeRange *> writes;
      memoryTracker_->elements(writes);

      for (unsigned i = 0; i < writes.size(); i++) {
         memoryTracker *tracker = dynamic_cast<memoryTracker *>(writes[i]);
         assert(tracker);
         //inst_printf("memory tracker: 0x%lx  load=0x%lx  size=%d  %s\n", 
         //tracker->get_local_ptr(), tracker->get_address(), tracker->get_size(),
         //tracker->alloced ? "[A]" : "");
         if (!tracker->alloced) continue;

         // Copy whatever is in there into the big buffer, at the appropriate address
         assert(tracker->get_address() >= lowWaterMark_);
         Address offset = tracker->get_address() - lowWaterMark_;
         assert((offset + tracker->get_size()) < highWaterMark_);
         void *ptr = (void *)(offset + (Address)newSectionPtr);
         memcpy(ptr, tracker->get_local_ptr(), tracker->get_size());
      }
            
      // Righto. Now, that includes the old binary - by design - 
      // so skip it and see what we're talking about size-wise. Which should
      // be less than the highWaterMark, so we can double-check.

      // Next, make a new section. We have the following parameters:
      // Offset vaddr: we get this from Symtab - "first free address with sufficient space"
      // std::string name: without reflection, ".dyninstInst"
      // unsigned long flags: these are a SymtabAPI abstraction. We're going with text|data because
      //    we might have both.
      // bool loadable: heck yeah...
        
      Region *newSec = NULL;
      symObj->findRegion(newSec, ".dyninstInst");
      if (newSec) {
         // We're re-instrumenting - will fail for now
         fprintf(stderr, "ERROR:  unable to reinstrument previously instrumented binary!\n");
         return false;
      }
        
      symObj->addRegion(lowWaterMark_,
                        newSectionPtr,
                        highWaterMark_ - lowWaterMark_,
                        ".dyninstInst",
                        Region::RT_TEXTDATA,
                        true);
        
      symObj->findRegion(newSec, ".dyninstInst");
      assert(newSec);

      if (mobj == getAOut()) {
         // Add dynamic symbol relocations
         for (unsigned i=0; i < dependentRelocations.size(); i++) {
            Address to = dependentRelocations[i]->getAddress();
            Symbol *referring = dependentRelocations[i]->getReferring();

            /*
            if (!symObj->isStaticBinary() && !symObj->hasReldyn() && !symObj->hasReladyn()) {
	      Address addr = referring->getOffset();
	      bool result = writeDataSpace((void *) to, getAddressWidth(), &addr);
	      assert(result);
	      continue;
	    }
            */

            // Create the relocationEntry
            relocationEntry localRel(to, referring->getMangledName(), referring,
                    relocationEntry::getGlobalRelType(getAddressWidth()));

            /*
            if( mobj->isSharedLib() ) {
                localRel.setRelAddr(to - mobj->imageOffset());
            }
            */

            symObj->addExternalSymbolReference(referring, newSec, localRel);

	    /*
	    newSymbol = new Symbol(referring->getName(), 
                                   Symbol::ST_FUNCTION, 
                                   Symbol::SL_GLOBAL,
                                   Symbol::SV_DEFAULT, 
                                   (Address)0, 
                                   symObj->getDefaultModule(),
                                   NULL, 
                                   8,
                                   true, 
                                   false);
            symObj->addSymbol(newSymbol, referring);
	    if (!symObj->hasReldyn() && symObj->hasReladyn()) {
               newSec->addRelocationEntry(to, newSymbol, relocationEntry::dynrel, Region::RT_RELA);
            } else {
               newSec->addRelocationEntry(to, newSymbol, relocationEntry::dynrel);
          }
          */
         }
      }

      pdvector<Symbol *> newSyms;
      buildDyninstSymbols(newSyms, newSec, symObj->getOrCreateModule("dyninstInst",
                                                                     lowWaterMark_));
      for (unsigned i = 0; i < newSyms.size(); i++) {
         symObj->addSymbol(newSyms[i]);
      }
        
      // Okay, now...
      // Hand textSection and newSection to DynSymtab.
        
      // First, textSection.
        
      // From the SymtabAPI documentation: we have the following methods we want to use.
      // Symtab::addSection(Offset vaddr, void *data, unsigned int dataSize, std::string name, 
      //                    unsigned long flags, bool loadable)
      // Symtab::updateCode(void *buffer, unsigned size)
      // Symtab::emit(std::string filename)
        
      // First, text
      assert(symObj);
        
#if 0
      for (unsigned i = 0; i < oldSegs.size(); i++) {
         if (oldSegs[i].data != newSegs[i].data) {
            inst_printf("Data not equivalent, %d, %s  load=0x%lx\n", 
			i, oldSegs[i].name.c_str(), oldSegs[i].loadaddr);
	    
            if (oldSegs[i].name == ".text" || 
		memcmp(oldSegs[i].data, newSegs[i].data, oldSegs[i].size < newSegs[i].size ? oldSegs[i].size : newSegs[i].size)) {
            //if ((oldSegs[i].name == ".text") 
             //|| (oldSegs[i].name == ".data")) {
               //inst_printf("  TEXT SEGMENT: old-base=0x%lx  old-size=%d  new-base=0x%lx  new-size=%d\n",
               //oldSegs[i].data, oldSegs[i].size, newSegs[i].data, newSegs[i].size);
               symObj->updateRegion(oldSegs[i].name.c_str(), newSegs[i].data,
                                  newSegs[i].size);
            }
         }
      }
#endif        

      // And now we generate the new binary
      //if (!symObj->emit(newFileName.c_str())) {
      if (!symObj->emit(newFileName.c_str())) {
         SymtabError lastError = Symtab::getLastSymtabError();
         showErrorCallback(109, Symtab::printError(lastError));
         return false;
      }
   return true;
}

bool BinaryEdit::inferiorMallocStatic(unsigned size) {
    // Should be set by now
    assert(highWaterMark_ != 0);

#if defined(USE_ADDRESS_MAPS)
    void *buf = malloc(size);
    if (!buf) return false;
#endif
    
    Address newStart = highWaterMark_;

    // If there is a free heap that _ends_ at the highWaterMark,
    // just extend it. This is a special case of inferiorFreeCompact;
    // when we make that function faster, we can just call it. 
    bool found = false;
    for (unsigned i = 0; i < heap_.heapFree.size(); i++) {
        heapItem *h = heap_.heapFree[i];
        assert(h);
        Address end = h->addr + h->length;
        if (end == newStart) {
            found = true;
            h->length += size;
            break;
        }
    }
    if (!found) {
        // Build tracking objects for it
        heapItem *h = new heapItem(highWaterMark_, 
                                   size,
                                   anyHeap,
                                   true,
                                   HEAPfree);
        addHeap(h);
    }

    highWaterMark_ += size;

    return true;
}


bool BinaryEdit::createMemoryBackingStore(mapped_object *obj) {
    // We want to create a buffer for every section in the
    // binary so that we can store updates.

    Symtab *symObj = obj->parse_img()->getObject();
    vector<Region*> regs;
    symObj->getAllRegions(regs);

   for (unsigned i = 0; i < regs.size(); i++) {
      memoryTracker *newTracker = NULL;
      if (regs[i]->getRegionType() == Region::RT_BSS || (regs[i]->getDiskSize() == 0))
      {
         continue;
      }
      else {
         newTracker = new memoryTracker(regs[i]->getRegionAddr(),
                                        regs[i]->getDiskSize(),
                                        regs[i]->getPtrToRawData());
         
      }
      newTracker->alloced = false;
      if (!memoryTracker_)
         memoryTracker_ = new codeRangeTree();
      memoryTracker_->insert(newTracker);
   }

    
   return true;
}


bool BinaryEdit::initialize() {
   //Load the RT library
   
   // Create the tramp guard
   
   // Initialization. For now we're skipping threads, since we can't
   // get the functions we need. However, we kinda need the recursion
   // guard. This is an integer (one per thread, for now - 1) that 
   // begins initialized to 1.

    return true;
}

void BinaryEdit::addDependentRelocation(Address to, Symbol *referring) {
    // prevent duplicate relocations
    std::vector<depRelocation *>::iterator it;
    for (it = dependentRelocations.begin(); it != dependentRelocations.end(); it++)
        if ((*it)->getAddress() == to && (*it)->getReferring() == referring)
            return;
    // create a new relocation and add it to the collection
	depRelocation *reloc = new depRelocation(to, referring);
	dependentRelocations.push_back(reloc);
}

Address BinaryEdit::getDependentRelocationAddr(Symbol *referring) {
	Address retAddr = 0x0;
	for (unsigned i=0; i < dependentRelocations.size(); i++) {
		if (dependentRelocations[i]->getReferring() == referring) {
			retAddr = dependentRelocations[i]->getAddress();
			break;
		}
	}
	return retAddr;
}


// Build a list of symbols describing instrumentation and relocated functions. 
// To keep this list (somewhat) short, we're doing one symbol per extent of 
// instrumentation + relocation for a particular function. 
// New: do this for one mapped object. 


void BinaryEdit::buildDyninstSymbols(pdvector<Symbol *> &newSyms, 
                                     Region *newSec,
                                     Module *newMod) {
    pdvector<codeRange *> ranges;
    textRanges_.elements(ranges);

    int_function *currFunc = NULL;
    codeRange *startRange = NULL;

    Address startAddr = 0;
    unsigned size = 0;

    for (unsigned i = 0; i < ranges.size(); i++) {
        multiTramp *multi = ranges[i]->is_multitramp();
        bblInstance *bbl = ranges[i]->is_basicBlockInstance();

        bool finishCurrentRegion = false;
        bool startNewRegion = false;
        bool extendCurrentRegion = false;

        if (multi) {
            if (multi->func() != currFunc) {
                finishCurrentRegion = true;
                startNewRegion = true;
            }
            else {
                extendCurrentRegion = true;
            }
        }
        else if (bbl) {
            if (bbl->func() != currFunc) {
                finishCurrentRegion = true;
                startNewRegion = true;
            }
            else {
                extendCurrentRegion = true;
            }
        }
        else
            continue;

        if (finishCurrentRegion && (currFunc != NULL)) {
            std::string name = currFunc->prettyName();
            name.append("_dyninst");

            Symbol *newSym = new Symbol(name.c_str(),
                                        Symbol::ST_FUNCTION,
                                        Symbol::SL_GLOBAL,
                                        Symbol::SV_DEFAULT,
                                        startAddr,
                                        newMod,
                                        newSec,
                                        size);
                                        
            newSyms.push_back(newSym);

            currFunc = NULL;
            startAddr = 0;
            size = 0;
            startRange = NULL;
        }
        if (startNewRegion) {
            assert(currFunc == NULL);
            
            currFunc = (multi != NULL) ? (multi->func()) : (bbl->func());
            assert(currFunc != NULL);
            startRange = ranges[i];
            startAddr = ranges[i]->get_address();
            size = ranges[i]->get_size();
        }
        if (extendCurrentRegion) {
            size += ranges[i]->get_size() + (ranges[i]->get_address() - (startAddr + size));
        }
    }
}
    
void BinaryEdit::markDirty()
{
   isDirty_ = true;
}

bool BinaryEdit::isDirty()
{
   return isDirty_;
}

mapped_object *BinaryEdit::getMappedObject()
{
   return mobj;
}

void BinaryEdit::setupRTLibrary(std::vector<BinaryEdit *> &r)
{
   rtlib = r;

   // Update addressSpace collection for RT library
   runtime_lib.clear();
   std::vector<BinaryEdit *>::iterator rtlib_it;
   for(rtlib_it = r.begin(); rtlib_it != r.end(); ++rtlib_it) {
       runtime_lib.insert((*rtlib_it)->getMappedObject());
   }
}

void BinaryEdit::setTrampGuard(int_variable* tg)
{
  trampGuardBase_ = tg;
}


int_variable* BinaryEdit::createTrampGuard()
{
  // If we have one, just return it
  if(trampGuardBase_) return trampGuardBase_;
  assert(rtlib.size());

  std::vector<BinaryEdit *>::iterator rtlib_it;
  const int_variable *var = NULL;
  for(rtlib_it = rtlib.begin(); rtlib_it != rtlib.end(); ++rtlib_it) {
      mapped_object *mobj = (*rtlib_it)->getMappedObject();
      var = mobj->getVariable("DYNINST_default_tramp_guards");
      if( var ) break;
  }
  
  assert(var);
  trampGuardBase_ = const_cast<int_variable *>(var);
  
  return trampGuardBase_;
}

vector<BinaryEdit *> &BinaryEdit::rtLibrary()
{
   return rtlib;
}

int_function *BinaryEdit::findOnlyOneFunction(const std::string &name,
                                              const std::string &libname,
                                              bool search_rt_lib)
{
   int_function *f = AddressSpace::findOnlyOneFunction(name, libname, search_rt_lib);
   if (!f && search_rt_lib) {
      std::vector<BinaryEdit *>::iterator rtlib_it;
      for(rtlib_it = rtlib.begin(); rtlib_it != rtlib.end(); ++rtlib_it) {
          f = (*rtlib_it)->findOnlyOneFunction(name, libname, false);
          if( f ) break;
      }
   }
   return f;
}

void BinaryEdit::setMultiThreadCapable(bool b)
{
   multithread_capable_ = b;
}

void BinaryEdit::addSibling(BinaryEdit *be)
{
   if (this != be) {
      siblings.push_back(be);
   }
}

std::vector<BinaryEdit *> &BinaryEdit::getSiblings()
{
   return siblings;
}



// Here's the story. We may need to install a trap handler for instrumentation
// to work in the rewritten binary. This doesn't play nicely with trap handlers
// that the binary itself registers. So we're going to replace every call to
// sigaction in the binary with a call to our wrapper. This wrapper:
//   1) Ignores attempts to register a SIGTRAP
//   2) Passes everything else through to sigaction
// It's called "dyn_sigaction".

bool BinaryEdit::usedATrap() {
    return (!trapMapping.empty());
}

bool BinaryEdit::replaceTrapHandler() {
    // Find all calls to sigaction and replace with
    // calls to dyn_sigaction. 

    // We haven't code generated yet, so we're working 
    // with addInst.

    int_function *dyn_sigaction = findOnlyOneFunction("dyn_sigaction");
    assert(dyn_sigaction);

    int_function *dyn_signal = findOnlyOneFunction("dyn_signal");
    assert(dyn_signal);

    bool success = true;
    
    pdvector<int_function *> allFuncs;
    getAllFunctions(allFuncs);

    for (unsigned i = 0; i < allFuncs.size(); i++) {
        int_function *func = allFuncs[i];
        
        assert(func);
        const pdvector<instPoint *> &calls = func->funcCalls();

        for (unsigned j = 0; j < calls.size(); j++) {
            instPoint *point = calls[j];
            
            std::string calleeName = point->getCalleeName();

            if ((calleeName == "sigaction") ||
                (calleeName == "_sigaction") ||
                (calleeName == "__sigaction")) {
                if (!replaceFunctionCall(point, dyn_sigaction)) {
                    success = false;
                }
            }
            else if ((calleeName == "signal") ||
                     (calleeName == "_signal") ||
                     (calleeName == "__signal"))
            {
               if (!replaceFunctionCall(point, dyn_signal)) {
                  success = false;
               }
            }
        }
    }
    
    return success;
}

bool BinaryEdit::needsPIC()
{
   Symtab *symtab = getMappedObject()->parse_img()->getObject();
   assert(symtab);
   if(getMappedObject()->fileName().find("lib") == 0)
   {
       if(getMappedObject()->fileName().find(".so") != std::string::npos)
       {
           return true;
       }
   }
   //If there is a fixed load address, then we can calculate 
   // absolute addresses.
   return (symtab->getLoadAddress() == 0);  
}
