/*
 * Copyright (c) 1996-2011 Barton P. Miller
 *
 * We provide the Paradyn Parallel Performance Tools (below
 * described as "Paradyn") on an AS IS basis, and do not warrant its
 * validity or performance.  We reserve the right to update, modify,
 * or discontinue this software at any time.  We shall have no
 * obligation to supply such updates or modifications or any other
 * form of support to you.
 *
 * By your use of Paradyn, you understand and agree that we (or any
 * other person or entity with proprietary rights in Paradyn) are
 * under no obligation to provide either maintenance services,
 * update services, notices of latent defects, or correction of
 * defects for Paradyn.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 */

// $Id: function.C,v 1.10 2005/03/02 19:44:45 bernat Exp

#include "function.h"
#include "process.h"
#include "instPoint.h"

#include "mapped_object.h"
#include "mapped_module.h"
#include "InstructionDecoder.h"
#include "MemoryEmulator/memEmulator.h"
#include "Relocation/Transformers/Movement-analysis.h"

#include "PatchMgr.h" // Scope

#include "Parsing.h"

#include "binaryEdit.h"

using namespace Dyninst;
using namespace Dyninst::ParseAPI;
using namespace Dyninst::Relocation;
using namespace Dyninst::PatchAPI;

int func_instance_count = 0;

func_instance::func_instance(parse_func *f,
                             Address baseAddr,
                             mapped_module *mod) :
  PatchFunction(f, mod->obj()),
  ptrAddr_(f->getPtrOffset() ? f->getPtrOffset() + baseAddr : 0),
  mod_(mod),
  handlerFaultAddr_(0),
  handlerFaultAddrAddr_(0)
#if defined(os_windows)
  , callingConv(unknown_call)
  , paramSize(0)
#endif
   , wrapperSym_(NULL)
{
  assert(f);
#if defined(ROUGH_MEMORY_PROFILE)
  func_instance_count++;
  if ((func_instance_count % 1000) == 0)
    fprintf(stderr, "func_instance_count: %d (%d)\n",
            func_instance_count, func_instance_count*sizeof(func_instance));
#endif

  parsing_printf("%s: creating new proc-specific function at 0x%lx\n",
                 symTabName().c_str(), addr_);

}

func_instance::func_instance(const func_instance *parFunc,
                             mapped_module *childMod) :
  PatchFunction(parFunc->ifunc(), childMod->obj()),
  ptrAddr_(parFunc->ptrAddr_),
  mod_(childMod),
  handlerFaultAddr_(0),
  handlerFaultAddrAddr_(0)
#if defined(os_windows)
  , callingConv(parFunc->callingConv)
  , paramSize(parFunc->paramSize)
#endif
   , wrapperSym_(NULL)
{
   assert(ifunc());
   // According to contract /w/ the mapped_object
   // all blocks have already been constructed.
   // Do we duplicate the parent or wait? I'm
   // tempted to wait, just because of the common
   // fork/exec case.
}

func_instance::~func_instance() {
  // We don't delete blocks, since they're shared between functions
  // We _do_ delete context instPoints, though
  // Except that should get taken care of normally since the
  // structures are static.
  for (unsigned i = 0; i < parallelRegions_.size(); i++)
    delete parallelRegions_[i];

}

void func_instance::setHandlerFaultAddr(Address fa) {
    handlerFaultAddr_ = fa;
}

// Sets the address in the structure at which the fault instruction's
// address is stored if "set" is true.  Accesses the fault address and
// translates it back to an original address if it corresponds to
// relocated code in the Dyninst heap
void func_instance::setHandlerFaultAddrAddr(Address faa, bool set) {
  if (set) {
    // save the faultAddrAddr
    handlerFaultAddrAddr_ = faa;
  }

  // get the faultAddr
  assert(proc()->proc());
  assert(sizeof(Address) == proc()->getAddressWidth());
  Address faultAddr=0;
  if (!proc()->readDataSpace
      ((void*)faa, proc()->getAddressWidth(), (void*)&faultAddr, true))
    {
      assert(0);
    }

  // translate the faultAddr back to an original address, and if
  // that translation was necessary, save it to the faultAddrAddr in the
  // CONTEXT struct
  if (proc()->proc()->isRuntimeHeapAddr(faultAddr)) {

    Address origAddr = faultAddr;
    vector<func_instance *> tmps;
    baseTramp *bti = NULL;
    bool success = proc()->getAddrInfo(faultAddr, origAddr, tmps, bti);
    assert(success);
    assert( proc()->writeDataSpace((void*)faa,
                                   sizeof(Address),
                                   (void*)&origAddr) );
  }
}

// Set the handler return addr to the most recent instrumented or
// relocated address, similar to instPoint::instrSideEffect.
// Also, make sure that we update our mapped view of memory,
// we may have overwritten memory that was previously not code
void func_instance::fixHandlerReturnAddr(Address /*faultAddr*/) {
    if ( !proc()->proc() || ! handlerFaultAddrAddr_ ) {
        assert(0);
        return;
    }
#if 0 //KEVINTODO: this function doesn't work, I tried setting newPC to 0xdeadbeef and it had no impact on the program's behavior.  If the springboards work properly this code is unneeded
    // Do a straightfoward forward map of faultAddr
    // First, get the original address
    func_instance *func;
    block_instance *block; baseTrampInstance *ignored;
    Address origAddr;
    if (!proc()->getRelocInfo(faultAddr, origAddr, block, ignored)) {
       func = dynamic_cast<process *>(proc())->findActiveFuncByAddr(faultAddr);
       origAddr = faultAddr;
    }
    else {
       func = block->func();
    }
    std::list<Address> relocAddrs;
    proc()->getRelocAddrs(origAddr, func, relocAddrs, true);
    Address newPC = (!relocAddrs.empty() ? relocAddrs.back() : origAddr);

    if (newPC != faultAddr) {
       if(!proc()->writeDataSpace((void*)handlerFaultAddrAddr_,
                                  sizeof(Address),
                                  (void*)&newPC)) {
          assert(0);
       }
    }
#endif
}

// Remove funcs from:
//   mapped_object & mapped_module datastructures
//   addressSpace::textRanges codeRangeTree<func_instance*>
//   image-level & SymtabAPI datastructures
//   BPatch_addressSpace::BPatch_funcMap <func_instance -> BPatch_function>
void func_instance::removeFromAll()
{
    mal_printf("purging blocks_ of size = %d from func at %lx\n",
               all_blocks_.size(), addr());

    // remove from mapped_object & mapped_module datastructures
    obj()->removeFunction(this);
    mod()->removeFunction(this);

    delete(this);
}

#if 0

/* Find parse_blocks that are missing from these datastructures and add
 * them.  The block_instance constructor does pretty much all of the work in
 * a chain of side-effects extending all the way into the mapped_object class
 *
 * We have to take into account that additional parsing may cause basic block splitting,
 * in which case it is necessary not only to add new int-level blocks, but to update
 * block_instance and BPatch_basicBlock objects.
 */
void func_instance::addMissingBlocks()
{
   assert(0 && "TODO");
    // A bit of a hack, but be sure that we've re-checked the blocks in the
    // parse_func as well.
    ifunc()->invalidateCache();

   blocks();
   // Add new blocks

   const vector<parse_block*> & nblocks = obj()->parse_img()->getNewBlocks();
   // add blocks by looking up new blocks, if it promises to be more
   // efficient than looking through all of the llfunc's blocks
   vector<parse_block*>::const_iterator nit = nblocks.begin();
   for( ; nit != nblocks.end(); ++nit) {
       if (ifunc()->contains(*nit)) {
           addMissingBlock(*nit);
       }
   }

   if (ifunc()->blocks().size() > blocks_.size()) { //not just the else case!
       // we may have parsed into an existing function and added its blocks
       // to ours, or this may just be a more efficient lookup method
       Function::blocklist & iblks = ifunc()->blocks();
       for (Function::blocklist::iterator bit = iblks.begin();
            bit != iblks.end();
            bit++)
       {
           if (!findBlock(*bit)) {
               addMissingBlock(SCAST_PB(*bit));
           }
       }
   }
}

void func_instance::getReachableBlocks(const set<block_instance*> &exceptBlocks,
                                      const list<block_instance*> &seedBlocks,
                                      set<block_instance*> &reachBlocks)//output
{
    list<parse_block*> imgSeeds;
    for (list<block_instance*>::const_iterator sit = seedBlocks.begin();
         sit != seedBlocks.end();
         sit++)
    {
        imgSeeds.push_back((*sit)->llb());
    }
    set<parse_block*> imgExcept;
    for (set<block_instance*>::const_iterator eit = exceptBlocks.begin();
         eit != exceptBlocks.end();
         eit++)
    {
        imgExcept.insert((*eit)->llb());
    }

    // image-level function does the work
    set<parse_block*> imgReach;
    ifunc()->getReachableBlocks(imgExcept,imgSeeds,imgReach);

    for (set<parse_block*>::iterator rit = imgReach.begin();
         rit != imgReach.end();
         rit++)
    {
        reachBlocks.insert( findBlock(*rit) );
    }
}
#endif

void print_func_vector_by_pretty_name(std::string prefix,
                                      pdvector<func_instance *>*funcs) {
    unsigned int i;
    func_instance *func;
    for(i=0;i<funcs->size();i++) {
      func = ((*funcs)[i]);
      cerr << prefix << func->prettyName() << endl;
    }
}

mapped_object *func_instance::obj() const { return mod()->obj(); }
AddressSpace *func_instance::proc() const { return obj()->proc(); }

const func_instance::BlockSet &func_instance::unresolvedCF() {
   if (unresolvedCF_.empty()) {
      // A block has unresolved control flow if it has an indirect
      // out-edge.
     for (blockset::const_iterator iter = getAllBlocks().begin(); iter != getAllBlocks().end(); ++iter) {
       block_instance* iblk = SCAST_BI(*iter);
         if (iblk->llb()->unresolvedCF()) {
            unresolvedCF_.insert(iblk);
         }
      }
   }
   return unresolvedCF_;
}

const func_instance::BlockSet &func_instance::abruptEnds() {
   if (abruptEnds_.empty()) {
      // A block has unresolved control flow if it has an indirect
      // out-edge.
     for (blockset::const_iterator iter = getAllBlocks().begin(); iter != getAllBlocks().end(); ++iter) {
       block_instance* iblk = SCAST_BI(*iter);
         if (iblk->llb()->abruptEnd()) {
            abruptEnds_.insert(iblk);
         }
      }
   }
   return abruptEnds_;
}

block_instance *func_instance::entryBlock() {
  return SCAST_BI(getEntryBlock());
}

unsigned func_instance::getNumDynamicCalls()
{
   unsigned count=0;
   for (blockset::const_iterator iter = getCallBlocks().begin(); iter != getCallBlocks().end(); ++iter) {
     block_instance* iblk = SCAST_BI(*iter);
      if (iblk->containsDynamicCall()) {
         count++;
      }
   }
   return count;
}


void func_instance::debugPrint() const {
    fprintf(stderr, "Function debug dump (%p):\n", this);
    fprintf(stderr, "  Symbol table names:\n");
    for (unsigned i = 0; i < symTabNameVector().size(); i++) {
        fprintf(stderr, "    %s\n", symTabNameVector()[i].c_str());
    }
    fprintf(stderr, "  Demangled names:\n");
    for (unsigned j = 0; j < prettyNameVector().size(); j++) {
        fprintf(stderr, "    %s\n", prettyNameVector()[j].c_str());
    }
    fprintf(stderr, "  Typed names:\n");
    for (unsigned k = 0; k < typedNameVector().size(); k++) {
        fprintf(stderr, "    %s\n", typedNameVector()[k].c_str());
    }
    fprintf(stderr, "  Address: 0x%lx\n", addr());
    fprintf(stderr, "  Internal pointer: %p\n", ifunc());
    fprintf(stderr, "  Object: %s (%p), module: %s (%p)\n",
            obj()->fileName().c_str(),
            obj(),
            mod()->fileName().c_str(),
            mod());
    for (blockset::const_iterator
         cb = all_blocks_.begin();
         cb != all_blocks_.end();
         cb++)
    {
        block_instance* orig = SCAST_BI(*cb);
        fprintf(stderr, "  Block start 0x%lx, end 0x%lx\n", orig->start(),
                orig->end());
    }
}

// Add to internal
// Add to mapped_object if a "new" name (true return from internal)
void func_instance::addSymTabName(const std::string name, bool isPrimary) {
    if (ifunc()->addSymTabName(name, isPrimary))
        obj()->addFunctionName(this, name, mapped_object::mangledName);
}

void func_instance::addPrettyName(const std::string name, bool isPrimary) {
    if (ifunc()->addPrettyName(name, isPrimary))
        obj()->addFunctionName(this, name, mapped_object::prettyName);
}

// Dig down to the low-level block of b, find the low-level functions
// that share it, and map up to int-level functions and add them
// to the funcs list.
bool func_instance::getSharingFuncs(block_instance *b,
                                   std::set<func_instance *> & funcs)
{
    bool ret = false;

    vector<Function *> lfuncs;
    b->llb()->getFuncs(lfuncs);
    vector<Function *>::iterator fit = lfuncs.begin();
    for( ; fit != lfuncs.end(); ++fit) {
      parse_func *ll_func = SCAST_PF(*fit);
        func_instance *hl_func = obj()->findFunction(ll_func);
        assert(hl_func);

        if (hl_func == this) continue;

        if (funcs.find(hl_func) == funcs.end()) ret = true;
        funcs.insert(hl_func);
    }

    return ret;
}

// Find sharing functions via checking all basic blocks. We might be
// able to check only exit points; but we definitely need to check _all_
// exits so for now we're checking everything.

bool func_instance::getSharingFuncs(std::set<func_instance *> &funcs) {
    bool ret = false;

    // Create the block list.
    blockset::const_iterator bIter;
    for (bIter = getAllBlocks().begin();
         bIter != getAllBlocks().end();
         bIter++) {
      block_instance* iblk = SCAST_BI(*bIter);
       if (getSharingFuncs(iblk,funcs))
          ret = true;
    }

    return ret;
}

bool func_instance::getOverlappingFuncs(block_instance *block,
                                       std::set<func_instance *> &funcs)
{
        ParseAPI::Block *llB = block->llb();
        std::set<ParseAPI::Block *> overlappingBlocks;
        for (Address i = llB->start(); i < llB->end(); ++i) {
                llB->obj()->findBlocks(llB->region(), i, overlappingBlocks);
        }
        // We now have all of the overlapping ParseAPI blocks. Get the set of
        // ParseAPI::Functions containing each and up-map to func_instances
        for (std::set<ParseAPI::Block *>::iterator iter = overlappingBlocks.begin();
                iter != overlappingBlocks.end(); ++iter) {
                std::vector<ParseAPI::Function *> llFuncs;
                (*iter)->getFuncs(llFuncs);
                for (std::vector<ParseAPI::Function *>::iterator iter2 = llFuncs.begin();
                     iter2 != llFuncs.end(); ++iter2)  {
                   funcs.insert(obj()->findFunction(*iter2));
                }
        }
        return (funcs.size() > 1);
}

bool func_instance::getOverlappingFuncs(std::set<func_instance *> &funcs)
{
    bool ret = false;

    // Create the block list.
    blockset::const_iterator bIter;
    for (bIter = getAllBlocks().begin();
         bIter != getAllBlocks().end();
         bIter++) {
      block_instance* iblk = SCAST_BI(*bIter);
       if (getOverlappingFuncs(iblk,funcs))
          ret = true;
    }

    return ret;
}

std::string func_instance::get_name() const
{
   return symTabName();
}

Offset func_instance::addrToOffset(const Address a) const {
   return a - (addr() - ifunc()->getOffset());
}

const pdvector< int_parRegion* > &func_instance::parRegions()
{
  if (parallelRegions_.size() > 0)
    return parallelRegions_;

  for (unsigned int i = 0; i < ifunc()->parRegions().size(); i++)
    {
      image_parRegion * imPR = ifunc()->parRegions()[i];
      //int_parRegion * iPR = new int_parRegion(imPR, baseAddr, this);
      int_parRegion * iPR = new int_parRegion(imPR, addr_, this);
      parallelRegions_.push_back(iPR);
    }
  return parallelRegions_;
}

bool func_instance::consistency() const {
   // 1) Check for 1:1 block relationship in
   //    the block list and block map
   // 2) Check that all instPoints are in the
   //    correct block.

   const ParseAPI::Function::blocklist &img_blocks = ifunc()->blocks();
   assert(img_blocks.size() == all_blocks_.size());
   for (ParseAPI::Function::blocklist::iterator iter = img_blocks.begin();
        iter != img_blocks.end(); ++iter) {
      parse_block *img_block = SCAST_PB(*iter);
      block_instance *b_inst = obj()->findBlock(img_block);
      assert(all_blocks_.find(b_inst) != all_blocks_.end());
   }

   return true;
}

Address func_instance::get_address() const { assert(0); return 0; }
unsigned func_instance::get_size() const { assert(0); return 0; }


bool func_instance::isInstrumentable() {
   return ifunc()->isInstrumentable();

   if (!ifunc()->isInstrumentable()) return false;

   // Hack: avoid things that throw exceptions
   // Make sure we parsed calls
   for (blockset::const_iterator iter = getCallBlocks().begin(); iter != getCallBlocks().end(); ++iter) {
      block_instance* iblk = SCAST_BI(*iter);
      if (iblk->calleeName().find("cxa_throw") != std::string::npos) {
         cerr << "Func " << symTabName() << " found exception ret false" << endl;
         return false;
      }
      func_instance *callee = iblk->callee();

      cerr << "Func " << symTabName() << " @ " << hex
           << iblk->start() << ", callee " << iblk->calleeName() << dec << endl;

      if (!callee) {
         cerr << "Warning: null callee" << endl;
         continue;
      }
      cerr << "Checking callee named " << callee->symTabName() << endl;

      if (callee->symTabName().find("cxa_throw") != std::string::npos) {
         cerr << "Func " << symTabName() << " found exception ret false" << endl;
         return false;
      }

      // TEMPORARY HACKAGE because we're not picking up names for
      // PLT functions?
      if (callee->symTabName().find("402700") != std::string::npos) {
         cerr << "Func " << symTabName() << " found exception ret false" << endl;
         return false;
      }
   }
   return true;
}

block_instance *func_instance::getBlock(const Address addr) {
        block_instance *block = obj()->findOneBlockByAddr(addr);
        // Make sure it's one of ours
        std::set<func_instance *> funcs;
        block->getFuncs(std::inserter(funcs, funcs.end()));
        if (funcs.find(this) != funcs.end()) {
          //addBlock(block); // Update parent class's bookkeeping stuffs
          return block;
        }
        return NULL;
}

using namespace SymtabAPI;

bool func_instance::addSymbolsForCopy() {
   // Not implemented for dynamic mode
   if (proc()->proc()) return false;
   // And not implemented for same-module

   // Get the old symbol
   Symbol *oldsym = getRelocSymbol();

   // Get the new symbol
   Symbol *wrapperSym = getWrapperSymbol();
   if (!wrapperSym) {
      return false;
   }
   // Now we split. If this is a static binary, we want to point all the relocations
   // in this function at the new symbol. If it's a dynamic binary, we can just relocate
   // the daylights out of it.
   if (obj()->isStaticExec()) {
      proc()->edit()->addDyninstSymbol(wrapperSym_);
      if (!updateRelocationsToSym(oldsym, wrapperSym)) return false;
   }
   else {
      // I think we just add this to the dynamic symbol table...
      wrapperSym->setDynamic(true);
      proc()->edit()->addDyninstSymbol(wrapperSym_);
   }

   return true;
}

bool func_instance::updateRelocationsToSym(Symbol *oldsym, Symbol *newsym) {
   for (blockset::const_iterator iter = getAllBlocks().begin();
        iter != getAllBlocks().end(); ++iter) {
      obj()->parse_img()->getObject()->updateRelocations((*iter)->start(), (*iter)->last(), oldsym, newsym);
   }
   return true;
}

Symbol *func_instance::getWrapperSymbol() {
   // Is created during relocation, which should have
   // already happened.
   return wrapperSym_;
}

Symbol *func_instance::getRelocSymbol() {
   // there should be only one...
   // HIGHLANDER!

   // find the Symbol corresponding to the func_instance
   std::vector<Symbol *> syms;
   ifunc()->func()->getSymbols(syms);

   if (syms.size() == 0) {
      char msg[256];
      sprintf(msg, "%s[%d]:  internal error:  cannot find symbol %s"
              , __FILE__, __LINE__, name().c_str());
      showErrorCallback(80, msg);
      assert(0);
   }

   // try to find a dynamic symbol
   // (take first static symbol if none are found)
   Symbol *referring = syms[0];
   for (unsigned k=0; k<syms.size(); k++) {
      if (syms[k]->isInDynSymtab()) {
         referring = syms[k];
         break;
      }
   }
   return referring;
}

void func_instance::createWrapperSymbol(Address entry, std::string name) {
   if (wrapperSym_) {
      // Just update the address
      wrapperSym_->setOffset(entry);
      return;
   }
   // Otherwise we need to create a new symbol
   wrapperSym_ = new Symbol(name,
                            Symbol::ST_FUNCTION,
                            Symbol::SL_GLOBAL,
                            Symbol::SV_DEFAULT,
                            entry,
                            NULL, // This is module - I probably want this?
                            NULL, // Region - again, find it?
                            0, // size - zero okay?
                            false, // Definitely not dynamic ("Static binaries don't have dynamic symbols - Dan")
                            false); // Definitely not absolute

}

/* PatchAPI stuffs */

instPoint *func_instance::funcEntryPoint(bool create) {
   // Lookup the cached points
   instPoint *p = IPCONV(proc()->mgr()->findPoint(Location(this), Point::FuncEntry, create));
   return p;
}

instPoint *func_instance::funcExitPoint(block_instance* b, bool create) {
   instPoint *p = IPCONV(proc()->mgr()->findPoint(Location(this, b), Point::FuncExit, create));
   return p;
}

void func_instance::funcExitPoints(Points* pts) {
  std::vector<Point*> points;
  proc()->mgr()->findPoints(Scope(this), Point::FuncExit, back_inserter(points));
  for (std::vector<Point*>::iterator pi = points.begin(); pi != points.end(); pi++) {
    instPoint* p = IPCONV(*pi);
    pts->push_back(p);
    assert(p->block());
  }
}

instPoint *func_instance::preCallPoint(block_instance* b, bool create) {
   instPoint *p = IPCONV(proc()->mgr()->findPoint(Location(this, b), Point::PreCall, create));
  return p;
}

instPoint *func_instance::postCallPoint(block_instance* b, bool create) {
   instPoint *p = IPCONV(proc()->mgr()->findPoint(Location(this, b), Point::PostCall, create));
   return p;
}

void func_instance::callPoints(Points* pts) {
  std::vector<Point*> points;
  proc()->mgr()->findPoints(Scope(this), Point::PreCall|Point::PostCall, back_inserter(points));
  for (std::vector<Point*>::iterator pi = points.begin(); pi != points.end(); pi++) {
     instPoint* p = static_cast<instPoint*>(*pi);
     pts->push_back(p);
  }
}

instPoint *func_instance::blockEntryPoint(block_instance* b, bool create) {
   instPoint *p = IPCONV(proc()->mgr()->findPoint(Location(this, b), Point::BlockEntry, create));
   return p;
}

instPoint *func_instance::blockExitPoint(block_instance* b, bool create) {
   instPoint *p = IPCONV(proc()->mgr()->findPoint(Location(this, b), Point::BlockExit, create));
   return p;
}

instPoint *func_instance::preInsnPoint(block_instance* b, Address a,
                                       InstructionAPI::Instruction::Ptr ptr,
                                       bool trusted, bool create) {
   Location loc;
   if (trusted) {
      loc = Location(this, InsnLoc(b, a, ptr));
   }
   else {
      loc = Location(this, b, a, ptr);
   }
   instPoint *p = IPCONV(proc()->mgr()->findPoint(loc, Point::PreInsn, create));
   return p;
}

instPoint *func_instance::postInsnPoint(block_instance* b, Address a,
                                        InstructionAPI::Instruction::Ptr ptr,
                                        bool trusted, bool create) {
   Location loc;
   if (trusted) {
      loc = Location(this, InsnLoc(b, a, ptr));
   }
   else {
      loc = Location(this, b, a, ptr);
   }
   instPoint *p = IPCONV(proc()->mgr()->findPoint(loc, Point::PostInsn, create));
   return p;
}

void func_instance::blockInsnPoints(block_instance* b, Points* pts) {
  std::vector<Point*> points;
  proc()->mgr()->findPoints(Scope(this, b), Point::PreInsn|Point::PostInsn, back_inserter(points));
  assert(points.size() > 0);
  for (std::vector<Point*>::iterator i = points.begin(); i != points.end(); i++) {
    instPoint* pt = static_cast<instPoint*>(*i);
    pts->push_back(pt);
  }
}

instPoint* func_instance::edgePoint(edge_instance* e, bool create) {
   instPoint *p = IPCONV(proc()->mgr()->findPoint(Location(this, e), Point::EdgeDuring, create));
   return p;
}

void func_instance::edgePoints(Points* pts) {
   std::vector<Point *> points;
   proc()->mgr()->findPoints(Scope(this), Point::EdgeDuring, back_inserter(points));
   for (std::vector<Point*>::iterator i = points.begin(); i != points.end(); i++) {
      instPoint* pt = static_cast<instPoint*>(*i);
      edge_instance* e = static_cast<edge_instance*>(pt->edge());
      pts->push_back(pt);
   }
}

void func_instance::destroyBlock(block_instance *block) {
   // Put things here that go away from the perspective of this function
}

void func_instance::destroy(func_instance *f) {
   // Put things here that go away when we destroy this function
   delete f;
}
