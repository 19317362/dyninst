\subsection{Symbolic Expansion and Evaluation}
\label{sec:symeval}

\definedin{SymEval.h}

Class SymEval provides interfaces for expanding an instruction to its semantic
representation and generating symbolic expressions for variables defined in a
user provided slicing result. The common foundation for instruction semantic
representation and variable symbolic expressions is an Abstract Syntax Tree
(AST) framework. The instruction semantic representation contains an AST for
each register written by this instruction. The variable symbolic expression for
a slice contains an AST for each register defined in the slice and the AST is
after symbolic substitutions of known variables with corresponding ASTs. We
first introduce the main interfaces of SymEval and then describe the structure
of an AST.

\begin{apient}
typedef std::map<Assignment::Ptr, AST::Ptr, AssignmentPtrValueComp> Result_t;
\end{apient}
\apidesc{This data type represents the results of symbolic expansion and
substitution for a slice of assignments, where each Assignment is associated
with an AST.}

\begin{center}
\begin{tabular}{ll}
\toprule
Retval\_t & Meaning \\
\midrule
FAILED &  failed \\
WIDEN\_NODE & widen \\
FAILED\_TRANSLATION & failed translation \\
SKIPPED\_INPUT & skipped input \\
SUCCESS & success \\
\bottomrule
\end{tabular}
\end{center}

\begin{apient}
static std::pair<AST::Ptr, bool> expand(const Assignment::Ptr &assignment, 
                                        bool applyVisitors = true);
\end{apient}
\apidesc{This interface expands a single Assignment given by \code{assignment}
and returns a \code{std::pair}, in which the first element is the AST after
expansion and the second element is a bool indicating whether the expansion
succeeded or not. \code{applyVisitors} specifies whether or not to perform stack
analysis to precisely track stack variables.}


\begin{apient}
static bool expand(Result_t &res, 
                   std::set<InstructionPtr> &failedInsns,
		   bool applyVisitors = true);


\end{apient}
\apidesc{This interface expands a set of Assignment prepared in \code{res}. The
corresponding ASTs are written back into \code{res} and all instructions that
failed during expansion are inserted into \code{failedInsns}. \code{applyVisitors} 
specifies whether or not to perform stack analysis to precisely track stack variables. 
This function returns \code{true} when all assignments in \code{res} are
successfully expanded. }

\begin{apient}
static Retval_t expand(Dyninst::Graph::Ptr slice, DataflowAPI::Result_t &res);
\end{apient}
\apidesc{This interface expands a slice and return an AST for each assignment in
the slice. This function will perform substitution of ASTs.}

We use ASTs to represent symbolic expressions of each assignment. Our AST
includes the internal node type \code{ROSEOperation}, which abstracts the particular
operations performed with its child nodes, and two leave node types,
\code{Variable} and \code{Constant}.

\begin{apient}
struct Variable;
\end{apient}
\apidesc{A \code{Variable} represents a register or a memory location at a
particular address. The same register at different addresses is considered as
different Variable objects.}

\begin{apient}
Variable::Variable();
Variable::Variable(AbsRegion r);
Variable::Variable(AbsRegion r, Address a);
\end{apient}
\apidesc{The constructors of class Variable.}

\begin{apient}
bool Variable::operator==(const Variable &rhs) const;
bool Variable::operator<(const Variable &rhs) const; 

\end{apient}
\apidesc{Two Variable objects are equal when their AbsRegion are equal and their
addresses are equal.}

\begin{apient}
const std::string format() const;
\end{apient}
\apidesc{Return the string representation of the Variable.}

\begin{apient}
AbsRegion reg;
Address addr;
\end{apient}

\begin{apient}
struct Constant;
\end{apient}
\apidesc{A \code{Constant} object represents a constant value in code.}

\begin{apient}
Constant::Constant();
Constant::Constant(uint64_t v);
Constnat::Constant(uint64_t v, size_t s);
\end{apient}
\apidesc{Constructors a Constant objects.}

\begin{apient}
bool Constant::operator==(const Constant &rhs) const;
bool Constant::operator<(const Constant &rhs) const;
\end{apient}
\apidesc{Comparison operators for Constant objects. Comparison is based on the
value and size.}

\begin{apient}
const std::string Constant::format() const;
\end{apient}
\apidesc{Return the string representation of the Constant object.}

\begin{apient}
uint64\_t val;
size\_t size;
\end{apient}

// Define the operations used by ROSE

\begin{center}
\begin{tabular}{ll}
\toprule
ROSEOperation::Op & Meaning \\
\midrule
    nullOp  & No operation \\
    extractOp & Extract bit ranges from a value \\
    invertOp & Flip every bit \\
    negateOp & Negate the value \\
    signExtendOp & Sign-extend the value \\
    equalToZeroOp & Check whether the value is zero or not \\
    generateMaskOp & Generate mask \\
    LSBSetOp & LSB set op\\
    MSBSetOp & MSB set op \\
    concatOp & Concatenate two values to form a new value \\
    andOp & Bit-wise and operation \\
    orOp & Bit-wise or operation \\
    xorOp & Bit-wise xor operation \\
    addOp & Add operation \\
    rotateLOp & Rotate to left operation \\
    rotateROp & Rotate to right operation \\
    shiftLOp & Shift to left operation \\
    shiftROp & Shift to right operation \\
    shiftRArithOp & Arithmetic shift to right operation \\
    derefOp  & Dereference memory operation \\
    writeRepOp & Write rep operation\\
    writeOp & Write operation\\
    ifOp & if operation \\
    sMultOp & Signed multiplication operation \\
    uMultOp & Unsigned multiplication operation \\
    sDivOp & Signed division operation \\
    sModOp & Signed modular operation \\
    uDivOp & Unsigned division operation \\    
    uModOp & Unsigned modular operation \\
    extendOp & Extend operation \\
    extendMSBOp & Extend Msb operation \\
\bottomrule
\end{tabular}
\end{center}

\begin{apient}
ROSEOperation::ROSEOperation(Op o) : op(o);
ROSEOperation::ROSEOperation(Op o, size_t s);
\end{apient}
\apidesc{Constructors for ROSEOperation}

\begin{apient}
bool ROSEOperation::operator==(const ROSEOperation &rhs) const;
\end{apient}
\apidesc{Equal operator}

\begin{apient}
const std::string ROSEOperation::format() const;
\end{apient}
\apidesc{Return the string representation.}

\begin{apient}
Op op;
size_t size;
\end{apient}


\begin{apient} 
DEF_AST_LEAF_TYPE(BottomAST, bool);
DEF_AST_LEAF_TYPE(ConstantAST, Constant);
DEF_AST_LEAF_TYPE(VariableAST, Variable);
DEF_AST_INTERNAL_TYPE(RoseAST, ROSEOperation);
\end{apient}



